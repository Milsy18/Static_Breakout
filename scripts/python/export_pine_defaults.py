# scripts/python/export_pine_defaults.py
"""
Export Pine v18 default thresholds from optimizer output.

Inputs
- --source: out/best_params_per_ml.csv (from run_opt.py)
- --enriched: (optional) enriched dataset to backfill medians if needed
- --out: directory for outputs (default: configs)

Outputs
- configs/pine_defaults_v18.yaml
- configs/pine_defaults_v18.txt   (array.from(...) blocks for Pine)
- out/pine_defaults_preview.txt   (human preview)
"""

from __future__ import annotations

import argparse
import math
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd
import numpy as np
import yaml

# Gates and their underlying feature names (must match run_opt.py / build_features.py)
GATE2FEATURE: Dict[str, str] = {
    "rsi": "rsi_z",
    "adx": "adx_z",
    "cmf": "cmf_z",
    "rvol": "rvol_z",
    "ema10_50": "ema_ratio_10_50",
    "ema50_200": "ema_ratio_50_200",
    "bbw": "bbw_pct",
    "range": "range_pct",
}

LEVELS: List[int] = list(range(1, 10))  # 1..9


def _round(x: float, n: int = 6) -> float:
    if x is None or (isinstance(x, float) and (math.isnan(x) or math.isinf(x))):
        return float("nan")
    return round(float(x), n)


def load_thresholds(source_csv: Path) -> pd.DataFrame:
    df = pd.read_csv(source_csv)
    # Expected columns: market_level, gate, threshold, feature (feature optional)
    needed = {"market_level", "gate", "threshold"}
    if not needed.issubset(set(df.columns)):
        raise ValueError(f"{source_csv} missing columns {needed - set(df.columns)}")
    return df


def backfill_from_enriched(df_en: pd.DataFrame, feature: str) -> Dict[int, float]:
    """Median per ML for a feature, used to backfill bbw/range when missing."""
    if "market_level" not in df_en.columns or feature not in df_en.columns:
        return {}
    med = (
        df_en.groupby("market_level")[feature]
        .median()
        .reindex(LEVELS)
        .astype(float)
        .to_dict()
    )
    return med


def assemble_per_level_arrays(
    thr_df: pd.DataFrame, enriched_csv: Optional[Path]
) -> Dict[str, List[float]]:
    """
    Returns {feature_name: [thr_L1, ..., thr_L9]}
    """
    out: Dict[str, List[float]] = {}
    # Start from thresholds file
    for gate, feature in GATE2FEATURE.items():
        arr = [float("nan")] * len(LEVELS)
        sub = thr_df[thr_df["gate"] == gate]
        for _, r in sub.iterrows():
            lvl = int(r["market_level"]) if r["market_level"] != "all" else None
            if lvl is None:
                # global fill if ML not used
                arr = [_round(r["threshold"])] * len(LEVELS)
                break
            idx = LEVELS.index(lvl)
            arr[idx] = _round(r["threshold"])
        out[feature] = arr

    # Backfill medians for bbw_pct and range_pct from enriched if any NaNs
    if enriched_csv is not None:
        df_en = pd.read_csv(enriched_csv)
        for feat in ["bbw_pct", "range_pct"]:
            if feat not in out:
                continue
            if any(map(lambda v: (isinstance(v, float) and math.isnan(v)), out[feat])):
                med = backfill_from_enriched(df_en, feat)
                arr = out[feat]
                for i, lvl in enumerate(LEVELS):
                    if isinstance(arr[i], float) and math.isnan(arr[i]) and lvl in med:
                        arr[i] = _round(med[lvl])
                out[feat] = arr
    # Replace remaining NaN with sensible constants:
    # z-scores -> 0, ema ratios -> 1, bbw/range -> overall median of present values
    for feat, arr in out.items():
        if feat.endswith("_z"):
            fill = 0.0
        elif feat.startswith("ema_ratio_"):
            fill = 1.0
        elif feat in ("bbw_pct", "range_pct"):
            present = [v for v in arr if not (isinstance(v, float) and math.isnan(v))]
            fill = float(np.nanmedian(present)) if present else 0.0
        else:
            fill = 0.0
        out[feat] = [_round(v if not (isinstance(v, float) and math.isnan(v)) else fill) for v in arr]
    return out


def write_yaml(arrs: Dict[str, List[float]], out_path: Path):
    data = {
        "version": "v18.0",
        "levels": LEVELS,
        "thresholds": {k: [float(v) for v in vals] for k, vals in arrs.items()},
        "notes": "thresholds are per-market-level; used as Pine defaults; z-scores>=0, ema_ratio>=1, bbw<=median, range>=median",
    }
    out_path.write_text(yaml.safe_dump(data, sort_keys=True), encoding="utf-8")


def write_arrays_txt(arrs: Dict[str, List[float]], out_path: Path):
    lines = []
    lines.append("// Auto-generated by export_pine_defaults.py")
    lines.append("// One element per market level (1..9)")
    for feat in ["rsi_z", "adx_z", "cmf_z", "rvol_z", "ema_ratio_10_50", "ema_ratio_50_200", "bbw_pct", "range_pct"]:
        vals = arrs[feat]
        joined = ",".join(f"{v:.6f}" for v in vals)
        var_name = feat.replace("ema_ratio_", "ema_ratio_").replace("bbw_pct", "bbw_pct").replace("range_pct", "range_pct")
        lines.append(f"var {var_name}_thr = array.from({joined})")
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def write_preview(arrs: Dict[str, List[float]], out_path: Path):
    def row(k: str) -> str:
        vals = " ".join(f"{v:.4f}" for v in arrs[k])
        return f"{k:18s}: {vals}"
    lines = []
    lines.append("Pine defaults preview (per ML 1..9)")
    for k in ["rsi_z", "adx_z", "cmf_z", "rvol_z", "ema_ratio_10_50", "ema_ratio_50_200", "bbw_pct", "range_pct"]:
        lines.append(row(k))
    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--source", required=True, help="Path to out/best_params_per_ml.csv")
    ap.add_argument("--enriched", help="Optional enriched CSV to backfill medians (e.g., out/final_holy_grail_enriched.csv)")
    ap.add_argument("--out", default="configs", help="Output folder (default: configs)")
    args = ap.parse_args()

    src = Path(args.source)
    if not src.exists():
        raise FileNotFoundError(src)

    enriched = Path(args.enriched) if args.enriched else None
    if enriched is not None and not enriched.exists():
        enriched = None  # silently ignore

    thr_df = load_thresholds(src)
    arrs = assemble_per_level_arrays(thr_df, enriched)

    out_dir = Path(args.out)
    out_dir.mkdir(parents=True, exist_ok=True)

    yaml_path = out_dir / "pine_defaults_v18.yaml"
    txt_path = out_dir / "pine_defaults_v18.txt"
    write_yaml(arrs, yaml_path)
    write_arrays_txt(arrs, txt_path)

    # preview to /out for quick inspection
    prev_path = Path("out") / "pine_defaults_preview.txt"
    Path("out").mkdir(exist_ok=True)
    write_preview(arrs, prev_path)

    print(f"Wrote {yaml_path}")
    print(f"Wrote {txt_path}")
    print(f"Wrote preview -> {prev_path}")


if __name__ == "__main__":
    main()
